{"ast":null,"code":"var _s = $RefreshSig$();\n// import { useCallback } from \"react\";\n// import axios from \"axios\";\n\n// const useChatActions = (friend, onUpdateChat, setMessages, socketRef) => {\n\n//   const handleSend = useCallback(\n//     async (messageText = \"\") => {\n//       if (!friend || !friend.id || !friend.sender) return;\n\n//       if (messageText.trim()) {\n//         const newMessage = {\n//           id: Date.now(),\n//           text: messageText.trim(),\n//           type: \"sent\",\n//           timestamp: new Date(),\n//           isTemporary: false,\n//         };\n//         setMessages((prev) => [...prev, newMessage]);\n\n//         if (socketRef.current) {\n//           socketRef.current.emit(\"sendMessage\", {\n//             toUserId: friend.member,\n//             message: {\n//               id: newMessage.id,\n//               conversation_id: friend.id,\n//               sender: friend.sender,\n//               recipient: friend.member,\n//               content: newMessage.text,\n//               message_type: \"text\",\n//               timestamp: newMessage.timestamp.toISOString(),\n//               url: null,\n//             },\n//           });\n\n//           socketRef.current.emit(\"sendMessage\", {\n//             toUserId: friend.sender,\n//             message: {\n//               id: newMessage.id,\n//               conversation_id: friend.id,\n//               sender: friend.sender,\n//               recipient: friend.sender,\n//               content: newMessage.text,\n//               message_type: \"text\",\n//               timestamp: newMessage.timestamp.toISOString(),\n//               url: null,\n//             },\n//           });\n//         }\n\n//         try {\n//           await axios.post(\"http://localhost:5000/api/chat/send-message/\", {\n//             id: newMessage.id,\n//             conversationId: friend.id,\n//             sender: friend.sender,\n//             content: messageText.trim(),\n//             message_type: \"text\",\n//             timestamp: new Date().toISOString(),\n//             recipient: friend.member,\n//           });\n//         } catch (error) {\n//           console.error(\"L·ªói g·ª≠i tin nh·∫Øn:\", error);\n//         }\n//       } else {\n//         const likeMessage = {\n//           id: Date.now(),\n//           text: \"üëç\",\n//           type: \"sent\",\n//           timestamp: new Date(),\n//           isTemporary: false,\n//         };\n//         setMessages((prev) => [...prev, likeMessage]);\n\n//         if (socketRef.current) {\n//           socketRef.current.emit(\"sendMessage\", {\n//             toUserId: friend.member,\n//             message: {\n//               id: likeMessage.id,\n//               conversation_id: friend.id,\n//               sender: friend.sender,\n//               recipient: friend.member,\n//               content: \"üëç\",\n//               message_type: \"text\",\n//               timestamp: likeMessage.timestamp.toISOString(),\n//               url: null,\n//             },\n//           });\n\n//           socketRef.current.emit(\"sendMessage\", {\n//             toUserId: friend.sender,\n//             message: {\n//               id: likeMessage.id,\n//               conversation_id: friend.id,\n//               sender: friend.sender,\n//               recipient: friend.sender,\n//               content: \"üëç\",\n//               message_type: \"text\",\n//               timestamp: likeMessage.timestamp.toISOString(),\n//               url: null,\n//             },\n//           });\n//         }\n\n//         try {\n//           await axios.post(\"http://localhost:5000/api/chat/send-message/\", {\n//             id: likeMessage.id,\n//             conversationId: friend.id,\n//             sender: friend.sender,\n//             content: \"üëç\",\n//             message_type: \"text\",\n//             timestamp: new Date().toISOString(),\n//             recipient: friend.member,\n//           });\n//         } catch (error) {\n//           console.error(\"L·ªói g·ª≠i tin nh·∫Øn like:\", error);\n//         }\n//       }\n//     },\n//     [friend, onUpdateChat, setMessages, socketRef]\n//   );\n\n//   const handleMediaSelect = useCallback(\n//     async (e, mediaType) => {\n//       if (!friend || !friend.id || !friend.sender) return;\n\n//       const file = e.target.files[0];\n//       if (!file) {\n//         alert(\"Vui l√≤ng ch·ªçn m·ªôt t·ªáp.\");\n//         return;\n//       }\n\n//       if (file.size > 50 * 1024 * 1024) {\n//         alert(\"T·ªáp qu√° l·ªõn. K√≠ch th∆∞·ªõc t·ªëi ƒëa l√† 50MB.\");\n//         return;\n//       }\n\n//       if (mediaType === \"image\" && !file.type.startsWith(\"image/\")) {\n//         alert(\"Vui l√≤ng ch·ªçn t·ªáp h√¨nh ·∫£nh.\");\n//         return;\n//       }\n\n//       if (mediaType === \"video\" && !file.type.startsWith(\"video/\")) {\n//         alert(\"Vui l√≤ng ch·ªçn t·ªáp video.\");\n//         return;\n//       }\n\n//       const tempMessageId = Date.now() + Math.random();\n\n//       if (mediaType === \"file\") {\n//         await uploadFileDirectly(file, mediaType, tempMessageId);\n//       } else {\n//         const reader = new FileReader();\n//         reader.onload = () => {\n//           const tempMessage = {\n//             id: tempMessageId,\n//             type: \"sent\",\n//             timestamp: new Date(),\n//             uploading: true,\n//             fileName: file.name,\n//             isTemporary: true,\n//           };\n\n//           let base64Data = null;\n//           if (mediaType === \"image\") {\n//             tempMessage.temporaryImage = reader.result;\n//             base64Data = reader.result;\n//           } else if (mediaType === \"video\") {\n//             tempMessage.temporaryVideo = reader.result;\n//             base64Data = reader.result;\n//           }\n\n//           setMessages((prev) => [...prev, tempMessage]);\n\n//           if (socketRef.current) {\n//             socketRef.current.emit(\"sendMessage\", {\n//               toUserId: friend.member,\n//               message: {\n//                 id: tempMessageId,\n//                 conversation_id: friend.id,\n//                 sender: friend.sender,\n//                 recipient: friend.member,\n//                 content: file.name,\n//                 message_type: mediaType,\n//                 timestamp: new Date().toISOString(),\n//                 url: null,\n//                 base64Data: base64Data,\n//               },\n//             });\n\n//             socketRef.current.emit(\"sendMessage\", {\n//               toUserId: friend.sender,\n//               message: {\n//                 id: tempMessageId,\n//                 conversation_id: friend.id,\n//                 sender: friend.sender,\n//                 recipient: friend.sender,\n//                 content: file.name,\n//                 message_type: mediaType,\n//                 timestamp: new Date().toISOString(),\n//                 url: null,\n//                 base64Data: base64Data,\n//               },\n//             });\n//           }\n\n//           uploadFileToServer(file, mediaType, tempMessageId, base64Data);\n//         };\n\n//         reader.onerror = () => {\n//           alert(\"L·ªói khi ƒë·ªçc t·ªáp.\");\n//         };\n//         reader.readAsDataURL(file);\n//       }\n//     },\n//     [friend, onUpdateChat, setMessages, socketRef]\n//   );\n\n//   const uploadFileDirectly = async (file, mediaType, messageId) => {\n//     if (!friend || !friend.id || !friend.sender) return;\n\n//     const formData = new FormData();\n//     formData.append(\"file\", file, encodeURIComponent(file.name));\n\n//     try {\n//       const uploadingMessage = {\n//         id: messageId,\n//         type: \"sent\",\n//         timestamp: new Date(),\n//         uploading: true,\n//         fileName: file.name,\n//         isTemporary: false,\n//       };\n//       setMessages((prev) => [...prev, uploadingMessage]);\n\n//       const uploadResponse = await axios.post(`http://localhost:5000/upload-file`, formData, {\n//         headers: {\n//           \"Content-Type\": \"multipart/form-data\",\n//           \"Accept\": \"application/json\",\n//         },\n//       });\n\n//       if (uploadResponse.data.url) {\n//         const filePath = uploadResponse.data.url.replace(\"http://localhost:5000\", \"\");\n//         const fullUrl = uploadResponse.data.url;\n\n//         const fileMessage = {\n//           id: messageId,\n//           type: \"sent\",\n//           timestamp: new Date(),\n//           uploading: false,\n//           fileName: file.name,\n//           file: {\n//             name: decodeURIComponent(file.name),\n//             url: fullUrl,\n//           },\n//           isTemporary: false,\n//         };\n\n//         setMessages((prev) =>\n//           prev.map((msg) => {\n//             if (msg.id === messageId) {\n//               return fileMessage;\n//             }\n//             return msg;\n//           })\n//         );\n\n//         if (socketRef.current) {\n//           socketRef.current.emit(\"sendMessage\", {\n//             toUserId: friend.member,\n//             message: {\n//               id: messageId,\n//               conversation_id: friend.id,\n//               sender: friend.sender,\n//               recipient: friend.member,\n//               content: decodeURIComponent(file.name),\n//               message_type: mediaType,\n//               timestamp: new Date().toISOString(),\n//               url: filePath,\n//             },\n//           });\n\n//           socketRef.current.emit(\"sendMessage\", {\n//             toUserId: friend.sender,\n//             message: {\n//               id: messageId,\n//               conversation_id: friend.id,\n//               sender: friend.sender,\n//               recipient: friend.sender,\n//               content: decodeURIComponent(file.name),\n//               message_type: mediaType,\n//               timestamp: new Date().toISOString(),\n//               url: filePath,\n//             },\n//           });\n//         }\n\n//         try {\n//           await axios.post(\"http://localhost:5000/api/chat/send-message/\", {\n//             id: messageId,\n//             conversationId: friend.id,\n//             sender: friend.sender,\n//             content: decodeURIComponent(file.name),\n//             message_type: mediaType,\n//             timestamp: new Date().toISOString(),\n//             recipient: friend.member,\n//             url: filePath,\n//           });\n//         } catch (messageError) {\n//           console.error(\"L·ªói g·ª≠i tin nh·∫Øn:\", messageError);\n//         }\n//       }\n//     } catch (uploadError) {\n//       setMessages((prev) =>\n//         prev.map((msg) => {\n//           if (msg.id === messageId) {\n//             return {\n//               ...msg,\n//               uploading: false,\n//               error: true,\n//               isTemporary: false,\n//             };\n//           }\n//           return msg;\n//         })\n//       );\n//       alert(\"Upload th·∫•t b·∫°i: \" + (uploadError.response?.data?.error || uploadError.message));\n//     }\n//   };\n\n//   const uploadFileToServer = async (file, mediaType, messageId, base64Data = null) => {\n//     if (!friend || !friend.id || !friend.sender) return;\n\n//     const formData = new FormData();\n//     let endpoint;\n\n//     if (mediaType === \"image\") {\n//       formData.append(\"file\", file, encodeURIComponent(file.name));\n//       endpoint = \"/upload-file\";\n//     } else if (mediaType === \"video\") {\n//       formData.append(\"video\", file, encodeURIComponent(file.name));\n//       endpoint = \"/upload-file\";\n//     }\n\n//     try {\n//       const uploadResponse = await axios.post(`http://localhost:5000${endpoint}`, formData, {\n//         headers: {\n//           \"Content-Type\": \"multipart/form-data\",\n//           \"Accept\": \"application/json\",\n//         },\n//       });\n\n//       if (uploadResponse.data.url) {\n//         const filePath = uploadResponse.data.url.replace(\"http://localhost:5000\", \"\");\n//         const fullUrl = uploadResponse.data.url;\n\n//         setMessages((prev) =>\n//           prev.map((msg) => {\n//             if (msg.id === messageId) {\n//               const updatedMsg = {\n//                 ...msg,\n//                 uploading: false,\n//                 isTemporary: false,\n//                 image: mediaType === \"image\" ? fullUrl : msg.image,\n//                 video: mediaType === \"video\" ? fullUrl : msg.video,\n//               };\n//               return updatedMsg;\n//             }\n//             return msg;\n//           })\n//         );\n\n//         if (socketRef.current) {\n//           // G·ª≠i updateMessage t·ªõi ng∆∞·ªùi nh·∫≠n\n//           socketRef.current.emit(\"updateMessage\", {\n//             toUserId: friend.member,\n//             message: {\n//               id: messageId,\n//               conversation_id: friend.id,\n//               message_type: mediaType,\n//               content: decodeURIComponent(file.name),\n//               sender: friend.sender,\n//               recipient: friend.member,\n//               timestamp: new Date().toISOString(),\n//               url: filePath,\n//             },\n//           });\n\n//           // G·ª≠i sendMessage t·ªõi ch√≠nh ng∆∞·ªùi g·ª≠i\n//           socketRef.current.emit(\"sendMessage\", {\n//             toUserId: friend.sender,\n//             message: {\n//               id: messageId,\n//               conversation_id: friend.id,\n//               sender: friend.sender,\n//               recipient: friend.sender,\n//               content: decodeURIComponent(file.name),\n//               message_type: mediaType,\n//               timestamp: new Date().toISOString(),\n//               url: filePath,\n//             },\n//           });\n//         }\n\n//         try {\n//           await axios.post(\"http://localhost:5000/api/chat/send-message/\", {\n//             id: messageId,\n//             conversationId: friend.id,\n//             sender: friend.sender,\n//             content: decodeURIComponent(file.name),\n//             message_type: mediaType,\n//             timestamp: new Date().toISOString(),\n//             recipient: friend.member,\n//             url: filePath,\n//           });\n//         } catch (messageError) {\n//           console.error(\"L·ªói g·ª≠i tin nh·∫Øn:\", messageError);\n//         }\n//       }\n//     } catch (uploadError) {\n//       setMessages((prev) =>\n//         prev.map((msg) => {\n//           if (msg.id === messageId) {\n//             return {\n//               ...msg,\n//               uploading: false,\n//               error: true,\n//               isTemporary: false,\n//             };\n//           }\n//           return msg;\n//         })\n//       );\n//       alert(\"Upload th·∫•t b·∫°i: \" + (uploadError.response?.data?.error || uploadError.message));\n//     }\n//   };\n\n//   return { handleSend, handleMediaSelect };\n// };\n\n// export default useChatActions;\n\nimport { useCallback } from \"react\";\nimport axios from \"axios\";\nconst useChatActions = (friend, onUpdateChat, setMessages, socketRef) => {\n  _s();\n  const handleSend = useCallback(async (messageText = \"\") => {\n    if (!friend || !friend.id || !friend.sender) return;\n    if (messageText.trim()) {\n      const newMessage = {\n        id: Date.now(),\n        text: messageText.trim(),\n        type: \"sent\",\n        timestamp: new Date(),\n        isTemporary: false\n      };\n      setMessages(prev => [...prev, newMessage]);\n      if (socketRef.current) {\n        socketRef.current.emit(\"sendMessage\", {\n          toUserId: friend.member,\n          message: {\n            id: newMessage.id,\n            conversation_id: friend.id,\n            sender: friend.sender,\n            recipient: friend.member,\n            content: newMessage.text,\n            message_type: \"text\",\n            timestamp: newMessage.timestamp.toISOString(),\n            url: null\n          }\n        });\n        socketRef.current.emit(\"sendMessage\", {\n          toUserId: friend.sender,\n          message: {\n            id: newMessage.id,\n            conversation_id: friend.id,\n            sender: friend.sender,\n            recipient: friend.sender,\n            content: newMessage.text,\n            message_type: \"text\",\n            timestamp: newMessage.timestamp.toISOString(),\n            url: null\n          }\n        });\n      }\n      try {\n        await axios.post(\"http://localhost:5000/api/chat/send-message/\", {\n          id: newMessage.id,\n          conversationId: friend.id,\n          sender: friend.sender,\n          content: messageText.trim(),\n          message_type: \"text\",\n          timestamp: new Date().toISOString(),\n          recipient: friend.member\n        });\n      } catch (error) {\n        console.error(\"L·ªói g·ª≠i tin nh·∫Øn:\", error);\n      }\n    } else {\n      const likeMessage = {\n        id: Date.now(),\n        text: \"üëç\",\n        type: \"sent\",\n        timestamp: new Date(),\n        isTemporary: false\n      };\n      setMessages(prev => [...prev, likeMessage]);\n      if (socketRef.current) {\n        socketRef.current.emit(\"sendMessage\", {\n          toUserId: friend.member,\n          message: {\n            id: likeMessage.id,\n            conversation_id: friend.id,\n            sender: friend.sender,\n            recipient: friend.member,\n            content: \"üëç\",\n            message_type: \"text\",\n            timestamp: likeMessage.timestamp.toISOString(),\n            url: null\n          }\n        });\n        socketRef.current.emit(\"sendMessage\", {\n          toUserId: friend.sender,\n          message: {\n            id: likeMessage.id,\n            conversation_id: friend.id,\n            sender: friend.sender,\n            recipient: friend.sender,\n            content: \"üëç\",\n            message_type: \"text\",\n            timestamp: likeMessage.timestamp.toISOString(),\n            url: null\n          }\n        });\n      }\n      try {\n        await axios.post(\"http://localhost:5000/api/chat/send-message/\", {\n          id: likeMessage.id,\n          conversationId: friend.id,\n          sender: friend.sender,\n          content: \"üëç\",\n          message_type: \"text\",\n          timestamp: new Date().toISOString(),\n          recipient: friend.member\n        });\n      } catch (error) {\n        console.error(\"L·ªói g·ª≠i tin nh·∫Øn like:\", error);\n      }\n    }\n  }, [friend, onUpdateChat, setMessages, socketRef]);\n  const handleMediaSelect = useCallback(async (e, mediaType) => {\n    if (!friend || !friend.id || !friend.sender) return;\n    const file = e.target.files[0];\n    if (!file) {\n      alert(\"Vui l√≤ng ch·ªçn m·ªôt t·ªáp.\");\n      return;\n    }\n    if (file.size > 50 * 1024 * 1024) {\n      alert(\"T·ªáp qu√° l·ªõn. K√≠ch th∆∞·ªõc t·ªëi ƒëa l√† 50MB.\");\n      return;\n    }\n    if (mediaType === \"image\" && !file.type.startsWith(\"image/\")) {\n      alert(\"Vui l√≤ng ch·ªçn t·ªáp h√¨nh ·∫£nh.\");\n      return;\n    }\n    if (mediaType === \"video\" && !file.type.startsWith(\"video/\")) {\n      alert(\"Vui l√≤ng ch·ªçn t·ªáp video.\");\n      return;\n    }\n    const tempMessageId = Date.now() + Math.random();\n    if (mediaType === \"file\") {\n      await uploadFileDirectly(file, mediaType, tempMessageId);\n    } else {\n      const reader = new FileReader();\n      reader.onload = () => {\n        const tempMessage = {\n          id: tempMessageId,\n          type: \"sent\",\n          timestamp: new Date(),\n          uploading: true,\n          fileName: file.name,\n          isTemporary: true\n        };\n        let base64Data = null;\n        if (mediaType === \"image\") {\n          tempMessage.temporaryImage = reader.result;\n          base64Data = reader.result;\n        } else if (mediaType === \"video\") {\n          tempMessage.temporaryVideo = reader.result;\n          base64Data = reader.result;\n        }\n        setMessages(prev => [...prev, tempMessage]);\n        if (socketRef.current) {\n          socketRef.current.emit(\"sendMessage\", {\n            toUserId: friend.member,\n            message: {\n              id: tempMessageId,\n              conversation_id: friend.id,\n              sender: friend.sender,\n              recipient: friend.member,\n              content: file.name,\n              message_type: mediaType,\n              timestamp: new Date().toISOString(),\n              url: null,\n              base64Data: base64Data\n            }\n          });\n          socketRef.current.emit(\"sendMessage\", {\n            toUserId: friend.sender,\n            message: {\n              id: tempMessageId,\n              conversation_id: friend.id,\n              sender: friend.sender,\n              recipient: friend.sender,\n              content: file.name,\n              message_type: mediaType,\n              timestamp: new Date().toISOString(),\n              url: null,\n              base64Data: base64Data\n            }\n          });\n        }\n        uploadFileToServer(file, mediaType, tempMessageId, base64Data);\n      };\n      reader.onerror = () => {\n        alert(\"L·ªói khi ƒë·ªçc t·ªáp.\");\n      };\n      reader.readAsDataURL(file);\n    }\n  }, [friend, onUpdateChat, setMessages, socketRef]);\n  const uploadFileDirectly = async (file, mediaType, messageId) => {\n    if (!friend || !friend.id || !friend.sender) return;\n    const formData = new FormData();\n    formData.append(\"file\", file, encodeURIComponent(file.name));\n    try {\n      const uploadingMessage = {\n        id: messageId,\n        type: \"sent\",\n        timestamp: new Date(),\n        uploading: true,\n        fileName: file.name,\n        isTemporary: false\n      };\n      setMessages(prev => [...prev, uploadingMessage]);\n      const uploadResponse = await axios.post(`http://localhost:5000/upload-file`, formData, {\n        headers: {\n          \"Content-Type\": \"multipart/form-data\",\n          \"Accept\": \"application/json\"\n        }\n      });\n      if (uploadResponse.data.url) {\n        const filePath = uploadResponse.data.url.replace(\"http://localhost:5000\", \"\");\n        const fullUrl = uploadResponse.data.url;\n        const fileMessage = {\n          id: messageId,\n          type: \"sent\",\n          timestamp: new Date(),\n          uploading: false,\n          fileName: file.name,\n          file: {\n            name: decodeURIComponent(file.name),\n            url: fullUrl\n          },\n          isTemporary: false\n        };\n        setMessages(prev => prev.map(msg => {\n          if (msg.id === messageId) {\n            return fileMessage;\n          }\n          return msg;\n        }));\n        if (socketRef.current) {\n          socketRef.current.emit(\"sendMessage\", {\n            toUserId: friend.member,\n            message: {\n              id: messageId,\n              conversation_id: friend.id,\n              sender: friend.sender,\n              recipient: friend.member,\n              content: decodeURIComponent(file.name),\n              message_type: mediaType,\n              timestamp: new Date().toISOString(),\n              url: filePath\n            }\n          });\n          socketRef.current.emit(\"sendMessage\", {\n            toUserId: friend.sender,\n            message: {\n              id: messageId,\n              conversation_id: friend.id,\n              sender: friend.sender,\n              recipient: friend.sender,\n              content: decodeURIComponent(file.name),\n              message_type: mediaType,\n              timestamp: new Date().toISOString(),\n              url: filePath\n            }\n          });\n        }\n        try {\n          await axios.post(\"http://localhost:5000/api/chat/send-message/\", {\n            id: messageId,\n            conversationId: friend.id,\n            sender: friend.sender,\n            content: decodeURIComponent(file.name),\n            message_type: mediaType,\n            timestamp: new Date().toISOString(),\n            recipient: friend.member,\n            url: filePath\n          });\n        } catch (messageError) {\n          console.error(\"L·ªói g·ª≠i tin nh·∫Øn:\", messageError);\n        }\n      }\n    } catch (uploadError) {\n      var _uploadError$response, _uploadError$response2;\n      setMessages(prev => prev.map(msg => {\n        if (msg.id === messageId) {\n          return {\n            ...msg,\n            uploading: false,\n            error: true,\n            isTemporary: false\n          };\n        }\n        return msg;\n      }));\n      alert(\"Upload th·∫•t b·∫°i: \" + (((_uploadError$response = uploadError.response) === null || _uploadError$response === void 0 ? void 0 : (_uploadError$response2 = _uploadError$response.data) === null || _uploadError$response2 === void 0 ? void 0 : _uploadError$response2.error) || uploadError.message));\n    }\n  };\n  const uploadFileToServer = async (file, mediaType, messageId, base64Data = null) => {\n    if (!friend || !friend.id || !friend.sender) return;\n    const formData = new FormData();\n    let endpoint;\n    if (mediaType === \"image\") {\n      formData.append(\"file\", file, encodeURIComponent(file.name));\n      endpoint = \"/upload-file\";\n    } else if (mediaType === \"video\") {\n      // ‚úÖ S·ª¨A: ƒê·ªïi \"video\" th√†nh \"file\"\n      formData.append(\"file\", file, encodeURIComponent(file.name));\n      endpoint = \"/upload-file\";\n    }\n    try {\n      const uploadResponse = await axios.post(`http://localhost:5000${endpoint}`, formData, {\n        headers: {\n          \"Content-Type\": \"multipart/form-data\",\n          \"Accept\": \"application/json\"\n        }\n      });\n      if (uploadResponse.data.url) {\n        const filePath = uploadResponse.data.url.replace(\"http://localhost:5000\", \"\");\n        const fullUrl = uploadResponse.data.url;\n        setMessages(prev => prev.map(msg => {\n          if (msg.id === messageId) {\n            const updatedMsg = {\n              ...msg,\n              uploading: false,\n              isTemporary: false,\n              image: mediaType === \"image\" ? fullUrl : msg.image,\n              video: mediaType === \"video\" ? fullUrl : msg.video\n            };\n            return updatedMsg;\n          }\n          return msg;\n        }));\n        if (socketRef.current) {\n          // G·ª≠i updateMessage t·ªõi ng∆∞·ªùi nh·∫≠n\n          socketRef.current.emit(\"updateMessage\", {\n            toUserId: friend.member,\n            message: {\n              id: messageId,\n              conversation_id: friend.id,\n              message_type: mediaType,\n              content: decodeURIComponent(file.name),\n              sender: friend.sender,\n              recipient: friend.member,\n              timestamp: new Date().toISOString(),\n              url: filePath\n            }\n          });\n\n          // G·ª≠i sendMessage t·ªõi ch√≠nh ng∆∞·ªùi g·ª≠i\n          socketRef.current.emit(\"sendMessage\", {\n            toUserId: friend.sender,\n            message: {\n              id: messageId,\n              conversation_id: friend.id,\n              sender: friend.sender,\n              recipient: friend.sender,\n              content: decodeURIComponent(file.name),\n              message_type: mediaType,\n              timestamp: new Date().toISOString(),\n              url: filePath\n            }\n          });\n        }\n        try {\n          await axios.post(\"http://localhost:5000/api/chat/send-message/\", {\n            id: messageId,\n            conversationId: friend.id,\n            sender: friend.sender,\n            content: decodeURIComponent(file.name),\n            message_type: mediaType,\n            timestamp: new Date().toISOString(),\n            recipient: friend.member,\n            url: filePath\n          });\n        } catch (messageError) {\n          console.error(\"L·ªói g·ª≠i tin nh·∫Øn:\", messageError);\n        }\n      }\n    } catch (uploadError) {\n      var _uploadError$response3, _uploadError$response4;\n      setMessages(prev => prev.map(msg => {\n        if (msg.id === messageId) {\n          return {\n            ...msg,\n            uploading: false,\n            error: true,\n            isTemporary: false\n          };\n        }\n        return msg;\n      }));\n      alert(\"Upload th·∫•t b·∫°i: \" + (((_uploadError$response3 = uploadError.response) === null || _uploadError$response3 === void 0 ? void 0 : (_uploadError$response4 = _uploadError$response3.data) === null || _uploadError$response4 === void 0 ? void 0 : _uploadError$response4.error) || uploadError.message));\n    }\n  };\n  return {\n    handleSend,\n    handleMediaSelect\n  };\n};\n_s(useChatActions, \"ecHnZImNKkRzGuXtQYT0FlfCzDg=\");\nexport default useChatActions;","map":{"version":3,"names":["useCallback","axios","useChatActions","friend","onUpdateChat","setMessages","socketRef","_s","handleSend","messageText","id","sender","trim","newMessage","Date","now","text","type","timestamp","isTemporary","prev","current","emit","toUserId","member","message","conversation_id","recipient","content","message_type","toISOString","url","post","conversationId","error","console","likeMessage","handleMediaSelect","e","mediaType","file","target","files","alert","size","startsWith","tempMessageId","Math","random","uploadFileDirectly","reader","FileReader","onload","tempMessage","uploading","fileName","name","base64Data","temporaryImage","result","temporaryVideo","uploadFileToServer","onerror","readAsDataURL","messageId","formData","FormData","append","encodeURIComponent","uploadingMessage","uploadResponse","headers","data","filePath","replace","fullUrl","fileMessage","decodeURIComponent","map","msg","messageError","uploadError","_uploadError$response","_uploadError$response2","response","endpoint","updatedMsg","image","video","_uploadError$response3","_uploadError$response4"],"sources":["/home/ichigomazone/Vscode/ReactJs/new-ui/frontend/src/components/Chat/ChatAction/useChatActions.js"],"sourcesContent":["\n// import { useCallback } from \"react\";\n// import axios from \"axios\";\n\n// const useChatActions = (friend, onUpdateChat, setMessages, socketRef) => {\n\n//   const handleSend = useCallback(\n//     async (messageText = \"\") => {\n//       if (!friend || !friend.id || !friend.sender) return;\n\n//       if (messageText.trim()) {\n//         const newMessage = {\n//           id: Date.now(),\n//           text: messageText.trim(),\n//           type: \"sent\",\n//           timestamp: new Date(),\n//           isTemporary: false,\n//         };\n//         setMessages((prev) => [...prev, newMessage]);\n\n//         if (socketRef.current) {\n//           socketRef.current.emit(\"sendMessage\", {\n//             toUserId: friend.member,\n//             message: {\n//               id: newMessage.id,\n//               conversation_id: friend.id,\n//               sender: friend.sender,\n//               recipient: friend.member,\n//               content: newMessage.text,\n//               message_type: \"text\",\n//               timestamp: newMessage.timestamp.toISOString(),\n//               url: null,\n//             },\n//           });\n\n//           socketRef.current.emit(\"sendMessage\", {\n//             toUserId: friend.sender,\n//             message: {\n//               id: newMessage.id,\n//               conversation_id: friend.id,\n//               sender: friend.sender,\n//               recipient: friend.sender,\n//               content: newMessage.text,\n//               message_type: \"text\",\n//               timestamp: newMessage.timestamp.toISOString(),\n//               url: null,\n//             },\n//           });\n//         }\n\n//         try {\n//           await axios.post(\"http://localhost:5000/api/chat/send-message/\", {\n//             id: newMessage.id,\n//             conversationId: friend.id,\n//             sender: friend.sender,\n//             content: messageText.trim(),\n//             message_type: \"text\",\n//             timestamp: new Date().toISOString(),\n//             recipient: friend.member,\n//           });\n//         } catch (error) {\n//           console.error(\"L·ªói g·ª≠i tin nh·∫Øn:\", error);\n//         }\n//       } else {\n//         const likeMessage = {\n//           id: Date.now(),\n//           text: \"üëç\",\n//           type: \"sent\",\n//           timestamp: new Date(),\n//           isTemporary: false,\n//         };\n//         setMessages((prev) => [...prev, likeMessage]);\n\n//         if (socketRef.current) {\n//           socketRef.current.emit(\"sendMessage\", {\n//             toUserId: friend.member,\n//             message: {\n//               id: likeMessage.id,\n//               conversation_id: friend.id,\n//               sender: friend.sender,\n//               recipient: friend.member,\n//               content: \"üëç\",\n//               message_type: \"text\",\n//               timestamp: likeMessage.timestamp.toISOString(),\n//               url: null,\n//             },\n//           });\n\n//           socketRef.current.emit(\"sendMessage\", {\n//             toUserId: friend.sender,\n//             message: {\n//               id: likeMessage.id,\n//               conversation_id: friend.id,\n//               sender: friend.sender,\n//               recipient: friend.sender,\n//               content: \"üëç\",\n//               message_type: \"text\",\n//               timestamp: likeMessage.timestamp.toISOString(),\n//               url: null,\n//             },\n//           });\n//         }\n\n//         try {\n//           await axios.post(\"http://localhost:5000/api/chat/send-message/\", {\n//             id: likeMessage.id,\n//             conversationId: friend.id,\n//             sender: friend.sender,\n//             content: \"üëç\",\n//             message_type: \"text\",\n//             timestamp: new Date().toISOString(),\n//             recipient: friend.member,\n//           });\n//         } catch (error) {\n//           console.error(\"L·ªói g·ª≠i tin nh·∫Øn like:\", error);\n//         }\n//       }\n//     },\n//     [friend, onUpdateChat, setMessages, socketRef]\n//   );\n\n//   const handleMediaSelect = useCallback(\n//     async (e, mediaType) => {\n//       if (!friend || !friend.id || !friend.sender) return;\n\n//       const file = e.target.files[0];\n//       if (!file) {\n//         alert(\"Vui l√≤ng ch·ªçn m·ªôt t·ªáp.\");\n//         return;\n//       }\n\n//       if (file.size > 50 * 1024 * 1024) {\n//         alert(\"T·ªáp qu√° l·ªõn. K√≠ch th∆∞·ªõc t·ªëi ƒëa l√† 50MB.\");\n//         return;\n//       }\n\n//       if (mediaType === \"image\" && !file.type.startsWith(\"image/\")) {\n//         alert(\"Vui l√≤ng ch·ªçn t·ªáp h√¨nh ·∫£nh.\");\n//         return;\n//       }\n\n//       if (mediaType === \"video\" && !file.type.startsWith(\"video/\")) {\n//         alert(\"Vui l√≤ng ch·ªçn t·ªáp video.\");\n//         return;\n//       }\n\n//       const tempMessageId = Date.now() + Math.random();\n\n//       if (mediaType === \"file\") {\n//         await uploadFileDirectly(file, mediaType, tempMessageId);\n//       } else {\n//         const reader = new FileReader();\n//         reader.onload = () => {\n//           const tempMessage = {\n//             id: tempMessageId,\n//             type: \"sent\",\n//             timestamp: new Date(),\n//             uploading: true,\n//             fileName: file.name,\n//             isTemporary: true,\n//           };\n\n//           let base64Data = null;\n//           if (mediaType === \"image\") {\n//             tempMessage.temporaryImage = reader.result;\n//             base64Data = reader.result;\n//           } else if (mediaType === \"video\") {\n//             tempMessage.temporaryVideo = reader.result;\n//             base64Data = reader.result;\n//           }\n\n//           setMessages((prev) => [...prev, tempMessage]);\n\n//           if (socketRef.current) {\n//             socketRef.current.emit(\"sendMessage\", {\n//               toUserId: friend.member,\n//               message: {\n//                 id: tempMessageId,\n//                 conversation_id: friend.id,\n//                 sender: friend.sender,\n//                 recipient: friend.member,\n//                 content: file.name,\n//                 message_type: mediaType,\n//                 timestamp: new Date().toISOString(),\n//                 url: null,\n//                 base64Data: base64Data,\n//               },\n//             });\n\n//             socketRef.current.emit(\"sendMessage\", {\n//               toUserId: friend.sender,\n//               message: {\n//                 id: tempMessageId,\n//                 conversation_id: friend.id,\n//                 sender: friend.sender,\n//                 recipient: friend.sender,\n//                 content: file.name,\n//                 message_type: mediaType,\n//                 timestamp: new Date().toISOString(),\n//                 url: null,\n//                 base64Data: base64Data,\n//               },\n//             });\n//           }\n\n//           uploadFileToServer(file, mediaType, tempMessageId, base64Data);\n//         };\n\n//         reader.onerror = () => {\n//           alert(\"L·ªói khi ƒë·ªçc t·ªáp.\");\n//         };\n//         reader.readAsDataURL(file);\n//       }\n//     },\n//     [friend, onUpdateChat, setMessages, socketRef]\n//   );\n\n//   const uploadFileDirectly = async (file, mediaType, messageId) => {\n//     if (!friend || !friend.id || !friend.sender) return;\n\n//     const formData = new FormData();\n//     formData.append(\"file\", file, encodeURIComponent(file.name));\n\n//     try {\n//       const uploadingMessage = {\n//         id: messageId,\n//         type: \"sent\",\n//         timestamp: new Date(),\n//         uploading: true,\n//         fileName: file.name,\n//         isTemporary: false,\n//       };\n//       setMessages((prev) => [...prev, uploadingMessage]);\n\n//       const uploadResponse = await axios.post(`http://localhost:5000/upload-file`, formData, {\n//         headers: {\n//           \"Content-Type\": \"multipart/form-data\",\n//           \"Accept\": \"application/json\",\n//         },\n//       });\n\n//       if (uploadResponse.data.url) {\n//         const filePath = uploadResponse.data.url.replace(\"http://localhost:5000\", \"\");\n//         const fullUrl = uploadResponse.data.url;\n\n//         const fileMessage = {\n//           id: messageId,\n//           type: \"sent\",\n//           timestamp: new Date(),\n//           uploading: false,\n//           fileName: file.name,\n//           file: {\n//             name: decodeURIComponent(file.name),\n//             url: fullUrl,\n//           },\n//           isTemporary: false,\n//         };\n\n//         setMessages((prev) =>\n//           prev.map((msg) => {\n//             if (msg.id === messageId) {\n//               return fileMessage;\n//             }\n//             return msg;\n//           })\n//         );\n\n//         if (socketRef.current) {\n//           socketRef.current.emit(\"sendMessage\", {\n//             toUserId: friend.member,\n//             message: {\n//               id: messageId,\n//               conversation_id: friend.id,\n//               sender: friend.sender,\n//               recipient: friend.member,\n//               content: decodeURIComponent(file.name),\n//               message_type: mediaType,\n//               timestamp: new Date().toISOString(),\n//               url: filePath,\n//             },\n//           });\n\n//           socketRef.current.emit(\"sendMessage\", {\n//             toUserId: friend.sender,\n//             message: {\n//               id: messageId,\n//               conversation_id: friend.id,\n//               sender: friend.sender,\n//               recipient: friend.sender,\n//               content: decodeURIComponent(file.name),\n//               message_type: mediaType,\n//               timestamp: new Date().toISOString(),\n//               url: filePath,\n//             },\n//           });\n//         }\n\n//         try {\n//           await axios.post(\"http://localhost:5000/api/chat/send-message/\", {\n//             id: messageId,\n//             conversationId: friend.id,\n//             sender: friend.sender,\n//             content: decodeURIComponent(file.name),\n//             message_type: mediaType,\n//             timestamp: new Date().toISOString(),\n//             recipient: friend.member,\n//             url: filePath,\n//           });\n//         } catch (messageError) {\n//           console.error(\"L·ªói g·ª≠i tin nh·∫Øn:\", messageError);\n//         }\n//       }\n//     } catch (uploadError) {\n//       setMessages((prev) =>\n//         prev.map((msg) => {\n//           if (msg.id === messageId) {\n//             return {\n//               ...msg,\n//               uploading: false,\n//               error: true,\n//               isTemporary: false,\n//             };\n//           }\n//           return msg;\n//         })\n//       );\n//       alert(\"Upload th·∫•t b·∫°i: \" + (uploadError.response?.data?.error || uploadError.message));\n//     }\n//   };\n\n//   const uploadFileToServer = async (file, mediaType, messageId, base64Data = null) => {\n//     if (!friend || !friend.id || !friend.sender) return;\n\n//     const formData = new FormData();\n//     let endpoint;\n\n//     if (mediaType === \"image\") {\n//       formData.append(\"file\", file, encodeURIComponent(file.name));\n//       endpoint = \"/upload-file\";\n//     } else if (mediaType === \"video\") {\n//       formData.append(\"video\", file, encodeURIComponent(file.name));\n//       endpoint = \"/upload-file\";\n//     }\n\n//     try {\n//       const uploadResponse = await axios.post(`http://localhost:5000${endpoint}`, formData, {\n//         headers: {\n//           \"Content-Type\": \"multipart/form-data\",\n//           \"Accept\": \"application/json\",\n//         },\n//       });\n\n//       if (uploadResponse.data.url) {\n//         const filePath = uploadResponse.data.url.replace(\"http://localhost:5000\", \"\");\n//         const fullUrl = uploadResponse.data.url;\n\n//         setMessages((prev) =>\n//           prev.map((msg) => {\n//             if (msg.id === messageId) {\n//               const updatedMsg = {\n//                 ...msg,\n//                 uploading: false,\n//                 isTemporary: false,\n//                 image: mediaType === \"image\" ? fullUrl : msg.image,\n//                 video: mediaType === \"video\" ? fullUrl : msg.video,\n//               };\n//               return updatedMsg;\n//             }\n//             return msg;\n//           })\n//         );\n\n//         if (socketRef.current) {\n//           // G·ª≠i updateMessage t·ªõi ng∆∞·ªùi nh·∫≠n\n//           socketRef.current.emit(\"updateMessage\", {\n//             toUserId: friend.member,\n//             message: {\n//               id: messageId,\n//               conversation_id: friend.id,\n//               message_type: mediaType,\n//               content: decodeURIComponent(file.name),\n//               sender: friend.sender,\n//               recipient: friend.member,\n//               timestamp: new Date().toISOString(),\n//               url: filePath,\n//             },\n//           });\n\n//           // G·ª≠i sendMessage t·ªõi ch√≠nh ng∆∞·ªùi g·ª≠i\n//           socketRef.current.emit(\"sendMessage\", {\n//             toUserId: friend.sender,\n//             message: {\n//               id: messageId,\n//               conversation_id: friend.id,\n//               sender: friend.sender,\n//               recipient: friend.sender,\n//               content: decodeURIComponent(file.name),\n//               message_type: mediaType,\n//               timestamp: new Date().toISOString(),\n//               url: filePath,\n//             },\n//           });\n//         }\n\n//         try {\n//           await axios.post(\"http://localhost:5000/api/chat/send-message/\", {\n//             id: messageId,\n//             conversationId: friend.id,\n//             sender: friend.sender,\n//             content: decodeURIComponent(file.name),\n//             message_type: mediaType,\n//             timestamp: new Date().toISOString(),\n//             recipient: friend.member,\n//             url: filePath,\n//           });\n//         } catch (messageError) {\n//           console.error(\"L·ªói g·ª≠i tin nh·∫Øn:\", messageError);\n//         }\n//       }\n//     } catch (uploadError) {\n//       setMessages((prev) =>\n//         prev.map((msg) => {\n//           if (msg.id === messageId) {\n//             return {\n//               ...msg,\n//               uploading: false,\n//               error: true,\n//               isTemporary: false,\n//             };\n//           }\n//           return msg;\n//         })\n//       );\n//       alert(\"Upload th·∫•t b·∫°i: \" + (uploadError.response?.data?.error || uploadError.message));\n//     }\n//   };\n\n//   return { handleSend, handleMediaSelect };\n// };\n\n// export default useChatActions;\n\n\nimport { useCallback } from \"react\";\nimport axios from \"axios\";\n\nconst useChatActions = (friend, onUpdateChat, setMessages, socketRef) => {\n\n  const handleSend = useCallback(\n    async (messageText = \"\") => {\n      if (!friend || !friend.id || !friend.sender) return;\n\n      if (messageText.trim()) {\n        const newMessage = {\n          id: Date.now(),\n          text: messageText.trim(),\n          type: \"sent\",\n          timestamp: new Date(),\n          isTemporary: false,\n        };\n        setMessages((prev) => [...prev, newMessage]);\n\n        if (socketRef.current) {\n          socketRef.current.emit(\"sendMessage\", {\n            toUserId: friend.member,\n            message: {\n              id: newMessage.id,\n              conversation_id: friend.id,\n              sender: friend.sender,\n              recipient: friend.member,\n              content: newMessage.text,\n              message_type: \"text\",\n              timestamp: newMessage.timestamp.toISOString(),\n              url: null,\n            },\n          });\n\n          socketRef.current.emit(\"sendMessage\", {\n            toUserId: friend.sender,\n            message: {\n              id: newMessage.id,\n              conversation_id: friend.id,\n              sender: friend.sender,\n              recipient: friend.sender,\n              content: newMessage.text,\n              message_type: \"text\",\n              timestamp: newMessage.timestamp.toISOString(),\n              url: null,\n            },\n          });\n        }\n\n        try {\n          await axios.post(\"http://localhost:5000/api/chat/send-message/\", {\n            id: newMessage.id,\n            conversationId: friend.id,\n            sender: friend.sender,\n            content: messageText.trim(),\n            message_type: \"text\",\n            timestamp: new Date().toISOString(),\n            recipient: friend.member,\n          });\n        } catch (error) {\n          console.error(\"L·ªói g·ª≠i tin nh·∫Øn:\", error);\n        }\n      } else {\n        const likeMessage = {\n          id: Date.now(),\n          text: \"üëç\",\n          type: \"sent\",\n          timestamp: new Date(),\n          isTemporary: false,\n        };\n        setMessages((prev) => [...prev, likeMessage]);\n\n        if (socketRef.current) {\n          socketRef.current.emit(\"sendMessage\", {\n            toUserId: friend.member,\n            message: {\n              id: likeMessage.id,\n              conversation_id: friend.id,\n              sender: friend.sender,\n              recipient: friend.member,\n              content: \"üëç\",\n              message_type: \"text\",\n              timestamp: likeMessage.timestamp.toISOString(),\n              url: null,\n            },\n          });\n\n          socketRef.current.emit(\"sendMessage\", {\n            toUserId: friend.sender,\n            message: {\n              id: likeMessage.id,\n              conversation_id: friend.id,\n              sender: friend.sender,\n              recipient: friend.sender,\n              content: \"üëç\",\n              message_type: \"text\",\n              timestamp: likeMessage.timestamp.toISOString(),\n              url: null,\n            },\n          });\n        }\n\n        try {\n          await axios.post(\"http://localhost:5000/api/chat/send-message/\", {\n            id: likeMessage.id,\n            conversationId: friend.id,\n            sender: friend.sender,\n            content: \"üëç\",\n            message_type: \"text\",\n            timestamp: new Date().toISOString(),\n            recipient: friend.member,\n          });\n        } catch (error) {\n          console.error(\"L·ªói g·ª≠i tin nh·∫Øn like:\", error);\n        }\n      }\n    },\n    [friend, onUpdateChat, setMessages, socketRef]\n  );\n\n  const handleMediaSelect = useCallback(\n    async (e, mediaType) => {\n      if (!friend || !friend.id || !friend.sender) return;\n\n      const file = e.target.files[0];\n      if (!file) {\n        alert(\"Vui l√≤ng ch·ªçn m·ªôt t·ªáp.\");\n        return;\n      }\n\n      if (file.size > 50 * 1024 * 1024) {\n        alert(\"T·ªáp qu√° l·ªõn. K√≠ch th∆∞·ªõc t·ªëi ƒëa l√† 50MB.\");\n        return;\n      }\n\n      if (mediaType === \"image\" && !file.type.startsWith(\"image/\")) {\n        alert(\"Vui l√≤ng ch·ªçn t·ªáp h√¨nh ·∫£nh.\");\n        return;\n      }\n\n      if (mediaType === \"video\" && !file.type.startsWith(\"video/\")) {\n        alert(\"Vui l√≤ng ch·ªçn t·ªáp video.\");\n        return;\n      }\n\n      const tempMessageId = Date.now() + Math.random();\n\n      if (mediaType === \"file\") {\n        await uploadFileDirectly(file, mediaType, tempMessageId);\n      } else {\n        const reader = new FileReader();\n        reader.onload = () => {\n          const tempMessage = {\n            id: tempMessageId,\n            type: \"sent\",\n            timestamp: new Date(),\n            uploading: true,\n            fileName: file.name,\n            isTemporary: true,\n          };\n\n          let base64Data = null;\n          if (mediaType === \"image\") {\n            tempMessage.temporaryImage = reader.result;\n            base64Data = reader.result;\n          } else if (mediaType === \"video\") {\n            tempMessage.temporaryVideo = reader.result;\n            base64Data = reader.result;\n          }\n\n          setMessages((prev) => [...prev, tempMessage]);\n\n          if (socketRef.current) {\n            socketRef.current.emit(\"sendMessage\", {\n              toUserId: friend.member,\n              message: {\n                id: tempMessageId,\n                conversation_id: friend.id,\n                sender: friend.sender,\n                recipient: friend.member,\n                content: file.name,\n                message_type: mediaType,\n                timestamp: new Date().toISOString(),\n                url: null,\n                base64Data: base64Data,\n              },\n            });\n\n            socketRef.current.emit(\"sendMessage\", {\n              toUserId: friend.sender,\n              message: {\n                id: tempMessageId,\n                conversation_id: friend.id,\n                sender: friend.sender,\n                recipient: friend.sender,\n                content: file.name,\n                message_type: mediaType,\n                timestamp: new Date().toISOString(),\n                url: null,\n                base64Data: base64Data,\n              },\n            });\n          }\n\n          uploadFileToServer(file, mediaType, tempMessageId, base64Data);\n        };\n\n        reader.onerror = () => {\n          alert(\"L·ªói khi ƒë·ªçc t·ªáp.\");\n        };\n        reader.readAsDataURL(file);\n      }\n    },\n    [friend, onUpdateChat, setMessages, socketRef]\n  );\n\n  const uploadFileDirectly = async (file, mediaType, messageId) => {\n    if (!friend || !friend.id || !friend.sender) return;\n\n    const formData = new FormData();\n    formData.append(\"file\", file, encodeURIComponent(file.name));\n\n    try {\n      const uploadingMessage = {\n        id: messageId,\n        type: \"sent\",\n        timestamp: new Date(),\n        uploading: true,\n        fileName: file.name,\n        isTemporary: false,\n      };\n      setMessages((prev) => [...prev, uploadingMessage]);\n\n      const uploadResponse = await axios.post(`http://localhost:5000/upload-file`, formData, {\n        headers: {\n          \"Content-Type\": \"multipart/form-data\",\n          \"Accept\": \"application/json\",\n        },\n      });\n\n      if (uploadResponse.data.url) {\n        const filePath = uploadResponse.data.url.replace(\"http://localhost:5000\", \"\");\n        const fullUrl = uploadResponse.data.url;\n\n        const fileMessage = {\n          id: messageId,\n          type: \"sent\",\n          timestamp: new Date(),\n          uploading: false,\n          fileName: file.name,\n          file: {\n            name: decodeURIComponent(file.name),\n            url: fullUrl,\n          },\n          isTemporary: false,\n        };\n\n        setMessages((prev) =>\n          prev.map((msg) => {\n            if (msg.id === messageId) {\n              return fileMessage;\n            }\n            return msg;\n          })\n        );\n\n        if (socketRef.current) {\n          socketRef.current.emit(\"sendMessage\", {\n            toUserId: friend.member,\n            message: {\n              id: messageId,\n              conversation_id: friend.id,\n              sender: friend.sender,\n              recipient: friend.member,\n              content: decodeURIComponent(file.name),\n              message_type: mediaType,\n              timestamp: new Date().toISOString(),\n              url: filePath,\n            },\n          });\n\n          socketRef.current.emit(\"sendMessage\", {\n            toUserId: friend.sender,\n            message: {\n              id: messageId,\n              conversation_id: friend.id,\n              sender: friend.sender,\n              recipient: friend.sender,\n              content: decodeURIComponent(file.name),\n              message_type: mediaType,\n              timestamp: new Date().toISOString(),\n              url: filePath,\n            },\n          });\n        }\n\n        try {\n          await axios.post(\"http://localhost:5000/api/chat/send-message/\", {\n            id: messageId,\n            conversationId: friend.id,\n            sender: friend.sender,\n            content: decodeURIComponent(file.name),\n            message_type: mediaType,\n            timestamp: new Date().toISOString(),\n            recipient: friend.member,\n            url: filePath,\n          });\n        } catch (messageError) {\n          console.error(\"L·ªói g·ª≠i tin nh·∫Øn:\", messageError);\n        }\n      }\n    } catch (uploadError) {\n      setMessages((prev) =>\n        prev.map((msg) => {\n          if (msg.id === messageId) {\n            return {\n              ...msg,\n              uploading: false,\n              error: true,\n              isTemporary: false,\n            };\n          }\n          return msg;\n        })\n      );\n      alert(\"Upload th·∫•t b·∫°i: \" + (uploadError.response?.data?.error || uploadError.message));\n    }\n  };\n\n  const uploadFileToServer = async (file, mediaType, messageId, base64Data = null) => {\n    if (!friend || !friend.id || !friend.sender) return;\n\n    const formData = new FormData();\n    let endpoint;\n\n    if (mediaType === \"image\") {\n      formData.append(\"file\", file, encodeURIComponent(file.name));\n      endpoint = \"/upload-file\";\n    } else if (mediaType === \"video\") {\n      // ‚úÖ S·ª¨A: ƒê·ªïi \"video\" th√†nh \"file\"\n      formData.append(\"file\", file, encodeURIComponent(file.name));\n      endpoint = \"/upload-file\";\n    }\n\n    try {\n      const uploadResponse = await axios.post(`http://localhost:5000${endpoint}`, formData, {\n        headers: {\n          \"Content-Type\": \"multipart/form-data\",\n          \"Accept\": \"application/json\",\n        },\n      });\n\n      if (uploadResponse.data.url) {\n        const filePath = uploadResponse.data.url.replace(\"http://localhost:5000\", \"\");\n        const fullUrl = uploadResponse.data.url;\n\n        setMessages((prev) =>\n          prev.map((msg) => {\n            if (msg.id === messageId) {\n              const updatedMsg = {\n                ...msg,\n                uploading: false,\n                isTemporary: false,\n                image: mediaType === \"image\" ? fullUrl : msg.image,\n                video: mediaType === \"video\" ? fullUrl : msg.video,\n              };\n              return updatedMsg;\n            }\n            return msg;\n          })\n        );\n\n        if (socketRef.current) {\n          // G·ª≠i updateMessage t·ªõi ng∆∞·ªùi nh·∫≠n\n          socketRef.current.emit(\"updateMessage\", {\n            toUserId: friend.member,\n            message: {\n              id: messageId,\n              conversation_id: friend.id,\n              message_type: mediaType,\n              content: decodeURIComponent(file.name),\n              sender: friend.sender,\n              recipient: friend.member,\n              timestamp: new Date().toISOString(),\n              url: filePath,\n            },\n          });\n\n          // G·ª≠i sendMessage t·ªõi ch√≠nh ng∆∞·ªùi g·ª≠i\n          socketRef.current.emit(\"sendMessage\", {\n            toUserId: friend.sender,\n            message: {\n              id: messageId,\n              conversation_id: friend.id,\n              sender: friend.sender,\n              recipient: friend.sender,\n              content: decodeURIComponent(file.name),\n              message_type: mediaType,\n              timestamp: new Date().toISOString(),\n              url: filePath,\n            },\n          });\n        }\n\n        try {\n          await axios.post(\"http://localhost:5000/api/chat/send-message/\", {\n            id: messageId,\n            conversationId: friend.id,\n            sender: friend.sender,\n            content: decodeURIComponent(file.name),\n            message_type: mediaType,\n            timestamp: new Date().toISOString(),\n            recipient: friend.member,\n            url: filePath,\n          });\n        } catch (messageError) {\n          console.error(\"L·ªói g·ª≠i tin nh·∫Øn:\", messageError);\n        }\n      }\n    } catch (uploadError) {\n      setMessages((prev) =>\n        prev.map((msg) => {\n          if (msg.id === messageId) {\n            return {\n              ...msg,\n              uploading: false,\n              error: true,\n              isTemporary: false,\n            };\n          }\n          return msg;\n        })\n      );\n      alert(\"Upload th·∫•t b·∫°i: \" + (uploadError.response?.data?.error || uploadError.message));\n    }\n  };\n\n  return { handleSend, handleMediaSelect };\n};\n\nexport default useChatActions;"],"mappings":";AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAGA,SAASA,WAAW,QAAQ,OAAO;AACnC,OAAOC,KAAK,MAAM,OAAO;AAEzB,MAAMC,cAAc,GAAGA,CAACC,MAAM,EAAEC,YAAY,EAAEC,WAAW,EAAEC,SAAS,KAAK;EAAAC,EAAA;EAEvE,MAAMC,UAAU,GAAGR,WAAW,CAC5B,OAAOS,WAAW,GAAG,EAAE,KAAK;IAC1B,IAAI,CAACN,MAAM,IAAI,CAACA,MAAM,CAACO,EAAE,IAAI,CAACP,MAAM,CAACQ,MAAM,EAAE;IAE7C,IAAIF,WAAW,CAACG,IAAI,CAAC,CAAC,EAAE;MACtB,MAAMC,UAAU,GAAG;QACjBH,EAAE,EAAEI,IAAI,CAACC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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}